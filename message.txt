Full Cursor IDE Build Initiation Prompt (Python/Pydantic)
Objective: Create a modular, runnable Python application that simulates a voice agent food ordering workflow. The system must be robustly typed and segmented into dedicated agents, managed by a central Orchestrator. The resulting code must be easily integrable via a REST endpoint (simulated here) by N8N.

Language Preference: Python (Use Pydantic for the data model).

Part 1: Foundational Data Model and Typing

Task: Define the central, immutable data model.

Create a Pydantic Model (OrderContext) Define a class named OrderContext inheriting from pydantic.BaseModel. It must include all fields with appropriate type hints and default values:

call_transcript_snippet: str = ""

user_name: str = ""

location_address: str = ""

dietary_restrictions: List[str] = []

food_preferences: List[str] = []

price_range: str = ""

discovery_results: List[Dict] = [] (Each dict is an option).

final_selection: str = ""

order_status: str = "INITIATED" (Use this to track progress).

restaurant_call_script: str = ""

Create a Pydantic Model (DiscoveryOption) Define a class named DiscoveryOption for the items in discovery_results.

name: str

description: str

price: str (e.g., '15.99')

mock_order_link: str

Part 2: Agent Implementations (Modular Functions)

Task: Create three separate, isolated functions for the agent logic. All functions must accept an OrderContext and return a new, updated OrderContext (ensuring immutability is respected via the Pydantic .copy() method where updates are applied).

A. ðŸ‘‚ Preference Extraction Agent (extract_preferences)

Input: context: OrderContext

Logic: Implement logic to parse and extract structured data from context.call_transcript_snippet.

Mock Logic for Cursor: Use simple string parsing or mock a robust LLM call to set: user_name, location_address, dietary_restrictions, and food_preferences.

Output: The updated OrderContext.

B. ðŸ”Ž Discovery & Curation Agent (find_options)

Input: context: OrderContext

Logic: Use the extracted preferences to curate options.

Mock Logic for Cursor: Define a small, hardcoded list of DiscoveryOption objects (5-10 items). Implement filtering logic based on context.dietary_restrictions and context.food_preferences to select 1-3 highly relevant items.

Action: Populate context.discovery_results with the filtered DiscoveryOption objects.

Output: The updated OrderContext.

C. ðŸ“ž Mock Ordering Agent (place_mock_order)

Input: context: OrderContext

Pre-Req: Requires context.final_selection to be set.

Logic: Generate the final script for the voice agent.

Action: Construct the full, natural-language string for the restaurant_call_script using context.user_name, context.final_selection, and context.location_address.

Update: Set context.order_status = "MOCK_ORDER_PLACED".

Output: The updated OrderContext.

Part 3: Orchestrator and Main Execution Flow

Task: Create the main driver function to sequence the agents.

Orchestrator Function (run_workflow)

Input: initial_context: OrderContext

Logic: Implement the sequential flow:

Start: current_context = initial_context.copy()

current_context = extract_preferences(current_context)

current_context.order_status = "PREFERENCE_GATHERED"

current_context = find_options(current_context)

current_context.order_status = "OPTIONS_CURATED"

Mock Selection: Arbitrarily select the first item from discovery_results and set current_context.final_selection to its name (or simulate a customer selection prompt).

current_context.order_status = "ORDERING_INITIATED"

current_context = place_mock_order(current_context)

Output: The final, processed OrderContext.

Demonstration Block (if __name__ == "__main__":)

Include a demonstration block that:

Creates a sample OrderContext with a representative call_transcript_snippet.

Calls run_workflow().

Prints the final OrderContext and the restaurant_call_script clearly.